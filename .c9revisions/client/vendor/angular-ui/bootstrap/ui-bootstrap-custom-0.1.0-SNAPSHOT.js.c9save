{"ts":1380239478065,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"angular.module(\"ui.bootstrap\", [\"ui.bootstrap.dialog\"]);\n\n// The `$dialogProvider` can be used to configure global defaults for your\n// `$dialog` service.\nvar dialogModule = angular.module('ui.bootstrap.dialog', ['ui.bootstrap.transition']);\n\ndialogModule.controller('MessageBoxController', ['$scope', 'dialog', 'model', function($scope, dialog, model){\n  $scope.title = model.title;\n  $scope.message = model.message;\n  $scope.buttons = model.buttons;\n  $scope.close = function(res){\n    dialog.close(res);\n  };\n}]);\n\ndialogModule.provider(\"$dialog\", function(){\n\n  // The default options for all dialogs.\n\tvar defaults = {\n\t\tbackdrop: true,\n\t\tmodalClass: 'modal',\n\t\tbackdropClass: 'modal-backdrop',\n    transitionClass: 'fade',\n    triggerClass: 'in',\n\t\tresolve:{},\n\t\tbackdropFade: false,\n\t\tmodalFade:false,\n\t\tkeyboard: true, // close with esc key\n\t\tbackdropClick: true // only in conjunction with backdrop=true\n    /* other options: template, templateUrl, controller */\n\t};\n\n\tvar globalOptions = {};\n\n  // The `options({})` allows global configuration of all dialogs in the application.\n  //\n  //      var app = angular.module('App', ['ui.bootstrap.dialog'], function($dialogProvider){\n  //        // don't close dialog when backdrop is clicked by default\n  //        $dialogProvider.options({backdropClick: false});\n  //      });\n\tthis.options = function(value){\n\t\tglobalOptions = value;\n\t};\n\n  // Returns the actual `$dialog` service that is injected in controllers\n\tthis.$get = [\"$http\", \"$document\", \"$compile\", \"$rootScope\", \"$controller\", \"$templateCache\", \"$q\", \"$transition\",\n  function ($http, $document, $compile, $rootScope, $controller, $templateCache, $q, $transition) {\n\n\t\tvar body = $document.find('body');\n\n\t\tfunction createElement(clazz) {\n\t\t\tvar el = angular.element(\"<div>\");\n\t\t\tel.addClass(clazz);\n\t\t\treturn el;\n\t\t}\n\n    // The `Dialog` class represents a modal dialog. The dialog class can be invoked by providing an options object\n    // containing at lest template or templateUrl and controller:\n    // \n    //     var d = new Dialog({templateUrl: 'foo.html', controller: 'BarController'});\n    // \n    // Dialogs can also be created using templateUrl and controller as distinct arguments:\n    //\n    //     var d = new Dialog('path/to/dialog.html', MyDialogController);\n\t\tfunction Dialog(opts) {\n\n      var self = this, options = this.options = angular.extend({}, defaults, globalOptions, opts);\n\n      this.backdropEl = createElement(options.backdropClass);\n      if(options.backdropFade){\n        this.backdropEl.addClass(options.transitionClass);\n        this.backdropEl.removeClass(options.triggerClass);\n      }\n\n      this.modalEl = createElement(options.modalClass);\n      if(options.modalFade){\n        this.modalEl.addClass(options.transitionClass);\n        this.modalEl.removeClass(options.triggerClass);\n      }\n\n      this.handledEscapeKey = function(e) {\n        if (e.which === 27) {\n          self.close();\n          e.preventDefault();\n          self.$scope.$apply();\n        }\n      };\n\n      this.handleBackDropClick = function(e) {\n        self.close();\n        e.preventDefault();\n        self.$scope.$apply();\n      };\n    }\n\n    // The `isOpen()` method returns wether the dialog is currently visible.\n    Dialog.prototype.isOpen = function(){\n      return this._open;\n    };\n\n    // The `open(templateUrl, controller)` method opens the dialog.\n    // Use the `templateUrl` and `controller` arguments if specifying them at dialog creation time is not desired.\n    Dialog.prototype.open = function(templateUrl, controller){\n      var self = this, options = this.options;\n\n      if(templateUrl){\n        options.templateUrl = templateUrl;\n      }\n      if(controller){\n        options.controller = controller;\n      }\n      \n      if(!(options.template || options.templateUrl)) {\n        throw new Error('Dialog.open expected template or templateUrl, neither found. Use options or open method to specify them.');\n      }\n\n      this._loadResolves().then(function(locals) {\n        var $scope = locals.$scope = self.$scope = $rootScope.$new();\n\n        self.modalEl.html(locals.$template);\n\n        if (self.options.controller) {\n          var ctrl = $controller(self.options.controller, locals);\n          self.modalEl.contents().data('ngControllerController', ctrl);\n        }\n\n        $compile(self.modalEl.contents())($scope);\n        self._addElementsToDom();\n\n        // trigger tranisitions\n        setTimeout(function(){\n          if(self.options.modalFade){ self.modalEl.addClass(self.options.triggerClass); }\n          if(self.options.backdropFade){ self.backdropEl.addClass(self.options.triggerClass); }\n        });\n\n        self._bindEvents();\n      });\n\n      this.deferred = $q.defer();\n      return this.deferred.promise;\n    };\n\n    // closes the dialog and resolves the promise returned by the `open` method with the specified result.\n    Dialog.prototype.close = function(result){\n      var self = this;\n      var fadingElements = this._getFadingElements();\n\n      if(fadingElements.length > 0){\n        for (var i = fadingElements.length - 1; i >= 0; i--) {\n          $transition(fadingElements[i], removeTriggerClass).then(onCloseComplete);\n        }\n        return;\n      }\n      this._onCloseComplete(result);\n\n      function removeTriggerClass(el){\n        el.removeClass(self.options.triggerClass);\n      }\n\n      function onCloseComplete(){\n        if(self._open){\n          self._onCloseComplete(result);\n        }\n      }\n    };\n\n    Dialog.prototype._getFadingElements = function(){\n      var elements = [];\n      if(this.options.modalFade){\n        elements.push(this.modalEl);\n      }\n      if(this.options.backdropFade){\n        elements.push(this.backdropEl);\n      }\n\n      return elements;\n    };\n\n    Dialog.prototype._bindEvents = function() {\n      if(this.options.keyboard){ body.bind('keydown', this.handledEscapeKey); }\n      if(this.options.backdrop && this.options.backdropClick){ this.backdropEl.bind('click', this.handleBackDropClick); }\n    };\n\n    Dialog.prototype._unbindEvents = function() {\n      if(this.options.keyboard){ body.unbind('keydown', this.handledEscapeKey); }\n      if(this.options.backdrop && this.options.backdropClick){ this.backdropEl.unbind('click', this.handleBackDropClick); }\n    };\n\n    Dialog.prototype._onCloseComplete = function(result) {\n      this._removeElementsFromDom();\n      this._unbindEvents();\n      this.deferred.resolve(result);\n    };\n\n    Dialog.prototype._addElementsToDom = function(){\n      body.append(this.modalEl);\n      if(this.options.backdrop) { body.append(this.backdropEl); }\n      this._open = true;\n    };\n\n    Dialog.prototype._removeElementsFromDom = function(){\n      this.modalEl.remove();\n      if(this.options.backdrop) { this.backdropEl.remove(); }\n      this._open = false;\n    };\n\n    // Loads all `options.resolve` members to be used as locals for the controller associated with the dialog.\n    Dialog.prototype._loadResolves = function(){\n      var values = [], keys = [], templatePromise, self = this;\n\n      if (this.options.template) {\n        templatePromise = $q.when(this.options.template);\n      } else if (this.options.templateUrl) {\n        templatePromise = $http.get(this.options.templateUrl, {cache:$templateCache})\n        .then(function(response) { return response.data; });\n      }\n\n      angular.forEach(this.options.resolve || [], function(value, key) {\n        keys.push(key);\n        values.push(value);\n      });\n\n      keys.push('$template');\n      values.push(templatePromise);\n\n      return $q.all(values).then(function(values) {\n        var locals = {};\n        angular.forEach(values, function(value, index) {\n          locals[keys[index]] = value;\n        });\n        locals.dialog = self;\n        return locals;\n      });\n    };\n\n    // The actual `$dialog` service that is injected in controllers.\n    return {\n      // Creates a new `Dialog` with the specified options.\n      dialog: function(opts){\n        return new Dialog(opts);\n      },\n      // creates a new `Dialog` tied to the default message box template and controller.\n      //\n      // Arguments `title` and `message` are rendered in the modal header and body sections respectively.\n      // The `buttons` array holds an object with the following members for each button to include in the\n      // modal footer section:\n      //\n      // * `result`: the result to pass to the `close` method of the dialog when the button is clicked\n      // * `label`: the label of the button\n      // * `cssClass`: additional css class(es) to apply to the button for styling\n      messageBox: function(title, message, buttons){\n        return new Dialog({templateUrl: 'template/dialog/message.html', controller: 'MessageBoxController', resolve: {model: {\n          title: title,\n          message: message,\n          buttons: buttons\n        }}});\n      }\n    };\n  }];\n});\n\nangular.module('ui.bootstrap.transition', [])\n\n/**\n * $transition service provides a consistent interface to trigger CSS 3 transitions and to be informed when they complete.\n * @param  {DOMElement} element  The DOMElement that will be animated.\n * @param  {string|object|function} trigger  The thing that will cause the transition to start:\n *   - As a string, it represents the css class to be added to the element.\n *   - As an object, it represents a hash of style attributes to be applied to the element.\n *   - As a function, it represents a function to be called that will cause the transition to occur.\n * @return {Promise}  A promise that is resolved when the transition finishes.\n */\n.factory('$transition', ['$q', '$timeout', '$rootScope', function($q, $timeout, $rootScope) {\n\n  var $transition = function(element, trigger, options) {\n    options = options || {};\n    var deferred = $q.defer();\n    var endEventName = $transition[options.animation ? \"animationEndEventName\" : \"transitionEndEventName\"];\n\n    var transitionEndHandler = function(event) {\n      $rootScope.$apply(function() {\n        element.unbind(endEventName, transitionEndHandler);\n        deferred.resolve(element);\n      });\n    };\n\n    if (endEventName) {\n      element.bind(endEventName, transitionEndHandler);\n    }\n\n    // Wrap in a timeout to allow the browser time to update the DOM before the transition is to occur\n    $timeout(function() {\n      if ( angular.isString(trigger) ) {\n        element.addClass(trigger);\n      } else if ( angular.isFunction(trigger) ) {\n        trigger(element);\n      } else if ( angular.isObject(trigger) ) {\n        element.css(trigger);\n      }\n      //If browser does not support transitions, instantly resolve\n      if ( !endEventName ) {\n        deferred.resolve(element);\n      }\n    });\n\n    // Add our custom cancel function to the promise that is returned\n    // We can call this if we are about to run a new transition, which we know will prevent this transition from ending,\n    // i.e. it will therefore never raise a transitionEnd event for that transition\n    deferred.promise.cancel = function() {\n      if ( endEventName ) {\n        element.unbind(endEventName, transitionEndHandler);\n      }\n      deferred.reject('Transition cancelled');\n    };\n\n    return deferred.promise;\n  };\n\n  // Work out the name of the transitionEnd event\n  var transElement = document.createElement('trans');\n  var transitionEndEventNames = {\n    'WebkitTransition': 'webkitTransitionEnd',\n    'MozTransition': 'transitionend',\n    'OTransition': 'oTransitionEnd',\n    'msTransition': 'MSTransitionEnd',\n    'transition': 'transitionend'\n  };\n  var animationEndEventNames = {\n    'WebkitTransition': 'webkitAnimationEnd',\n    'MozTransition': 'animationend',\n    'OTransition': 'oAnimationEnd',\n    'msTransition': 'MSAnimationEnd',\n    'transition': 'animationend'\n  };\n  function findEndEventName(endEventNames) {\n    for (var name in endEventNames){\n      if (transElement.style[name] !== undefined) {\n        return endEventNames[name];\n      }\n    }\n  }\n  $transition.transitionEndEventName = findEndEventName(transitionEndEventNames);\n  $transition.animationEndEventName = findEndEventName(animationEndEventNames);\n  return $transition;\n}]);\n"]],"start1":0,"start2":0,"length1":0,"length2":12170}]],"length":12170}
